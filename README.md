# Estrutura De Dados

Conte√∫do das aulas e exerc√≠cios propostos na mat√©ria Estrutura de Dados ministrada pelo professor Leandro Colevati, cursada no 3¬∫ semestre do curso de an√°lise e desenvolvimento de sistemas na Faculdade de Tecnologia da Zona Leste (FATEC-ZL).

# Exerc√≠cios propostos

## [Aula01](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Aula01)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=12k7kal6sYeTY5oH6SeJsrnss2RDhzBFv&arquivo=ExerciciosAulaRecursividade.pdf)

Resolver, por recursividade, os problemas abaixo, fazendo o desenho do teste da solu√ß√£o, apresentando o ponto de parada e o retorno da fun√ß√£o para a pr√≥xima chamada. Fazer a implementa√ß√£o em Java na sequ√™ncia. Carregar o c√≥digo no Github.

- 1 - Criar uma fun√ß√£o recursiva que receba 2 valores A e B e, por somas, apresente o resultado da multiplica√ß√£o de A por B.

- 2 - Criar uma fun√ß√£o recursiva que receba o dividendo e o divisor de uma opera√ß√£o de divis√£o e, por subtra√ß√µes, exiba o resto da divis√£o.

- 3 - Construir uma fun√ß√£o recursiva que receba um vetor e seu tamanho e apresente a quantidade de n√∫meros pares existentes no vetor. Considere que a entrada deve ser, apenas de n√∫meros naturais diferentes de zero.

## [Recursividade01](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade01)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1EsAiBxl4nHoHmPSFZ7dj_2BiY4kkpdHa&arquivo=01-Recursividade.pdf) (pag. 17 a 20)

### [Exerc√≠cio 1](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/Recursividade01/src/controller/Exercicio01.java) 

Crie uma fun√ß√£o recursiva que exiba o resultado do fatorial de um n√∫mero (Pela limita√ß√£o da recursividade, o n√∫mero de entrada dever√°ser baixo para n√£o dar estouro(limite de entrada = 12)):

O c√≥digo deve trazer como coment√°rios:

- a) A condi√ß√£o de parada
- b) Como escrever a fun√ß√£o para o termo n em fun√ß√£o do termo anterior

### [Exerc√≠cio 2](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/Recursividade01/src/controller/Exercicio02.java) 

Crie uma fun√ß√£o recursiva que exiba o total de elementos negativos de um vetor de inteiros, de N posi√ß√µes, passado como par√¢metro:

O c√≥digo deve trazer como coment√°rios:

- a) A condi√ß√£o de parada
- b) Como escrever a fun√ß√£o para o termo n em fun√ß√£o do termo anterior

### [Exerc√≠cio 3](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/Recursividade01/src/controller/Exercicio03.java)

Crie uma fun√ß√£o recursiva que exiba a quantidade de d√≠gitos de um n√∫mero inteiro passado como par√¢metro:

O c√≥digo deve trazer como coment√°rios:

- a) A condi√ß√£o de parada
- b) Como escrever a fun√ß√£o para o termo n em fun√ß√£o do termo anterior

### [Exerc√≠cio 4](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/Recursividade01/src/controller/Exercicio04.java)

Crie uma fun√ß√£o recursiva que exiba o resultado da invers√£o de uma cadeia de caracteres (Ex.: entrada = teste ; sa√≠da = etset):

Deve se utilizar a fun√ß√£o SUBSTRING da Java

O c√≥digo deve trazer como coment√°rios:

- a) A condi√ß√£o de parada
- b) Como escrever a fun√ß√£o para o termo n em fun√ß√£o do termo anterior

## [Recursividade02.01](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.01/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Criar uma aplica√ß√£o em Java que tenha uma fun√ß√£o recursiva que calcule o somat√≥rio do N primeiros n√∫mero NATURAIS (a fun√ß√£o deve retornar zero para n√∫meros negativos)
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
condi√ß√£o de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
rela√ß√£o de chamada dos passos;

## [Recursividade02.02](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.02/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Criar uma aplica√ß√£o em Java que tenha uma fun√ß√£o recursiva que, recebendo um n√∫mero inteiro, converta para bin√°rio. Entrada limitada a 2000.
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
condi√ß√£o de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
rela√ß√£o de chamada dos passos;

## [Recursividade02.03](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.03/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Criar uma aplica√ß√£o em Java que tenha uma fun√ß√£o recursiva que, recebendo um n√∫mero inteiro (N), apresente a sa√≠da da somat√≥ria

    ùëÜ = 1 + 1/2 + 1/3 + 1/4 + ‚Ä¶ + 1/N

- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a condi√ß√£o de
parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a rela√ß√£o de chamada dos passos;

## [Recursividade02.04](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.04/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Criar uma aplica√ß√£o em Java que tenha uma fun√ß√£o recursiva que, recebendo um numero inteiro de 10 a 999999 e recebendo um 2¬∫ n√∫mero inteiro (de 0 a 9), tenha uma fun√ß√£o recursiva que apresente quantas vezes o 2¬∫ n√∫mero aparece no primeiro.

- Exemplo 1: 1¬∫. N√∫mero = 523578; 2¬∫. N√∫mero = 5; retorno aparece 2 vezes

- Exemplo 2: 1¬∫. N√∫mero = 836363; 2¬∫. N√∫mero = 3; retorno aparece 3 vezes

- A valida√ß√£o da entrada e do d√≠gito deve ser feito na main da aplica√ß√£o e n√£o na fun√ß√£o recursiva;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a condi√ß√£o de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a rela√ß√£o de chamada dos passos;

- Dica para a resolu√ß√£o do exerc√≠cio
    
    Exemplo: N√∫mero 1234

        1234 / 10 = 123 com resto 4
        123 / 10 = 12 com resto 3
        12 / 10 = 1 com resto 2
        1 / 10 = 0 com resto 1

    Exemplo: N√∫mero 8647

        8647 / 10 = 864 com resto 7
        864 / 10 = 86 com resto 4
        86 / 10 = 8 com resto 6
        8 / 10 = 0 com resto 8

## [Recursividade02.05](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.05/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Considere a s√©rie de Fibonacci:
 - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...

- Escrever uma fun√ß√£o recursiva que, dado uma posi√ß√£o da s√©rie, a fun√ß√£o
retorne seu valor. Entrada limitada a 20.
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a condi√ß√£o
de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a rela√ß√£o de
chamada dos passos;

## [Recursividade02.06](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.06/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Considerando exerc√≠cios realizados anteriormente, criar uma fun√ß√£o recursiva que solucione a fun√ß√£o (Entrada limitada a 10):

    ùëÜ = 1 + 1/2! + 1/3! + 1/4! + ‚Ä¶ + 1/ùëÅ!
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
condi√ß√£o de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
rela√ß√£o de chamada dos passos;

## [AlgoritmosOrdenacao](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/AlgoritmosOrdenacao/src/br/edu/fateczl/ordenacao)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F-sHe4u0eYJK8kl7xLWQY5bprglPfYv-&arquivo=03-AlgoritmosOrdenacao.pdf)

#### BUBBLE SORT

O Bubble Sort √© baseado em um algoritmo bastante simples, mas tem como comportamento percorrer o vetor diversas vezes, o que pode ser de bom desempenho com vetores pequenos e menos desordenados, mas perde desempenho em vetores m√©dios ou grandes.

DESCRI√á√ÉO:

- Pegar um vetor
- O n√∫mero de repeti√ß√µes dever√° ser igual ao tamanho do vetor
- A din√¢mica se d√° como segue:
    - Da primeira posi√ß√£o do vetor, at√© a pen√∫ltima posi√ß√£o;
    - Verificar se a posi√ß√£o atual √© maior que a pr√≥xima;
    - Se for, elas devem trocar de posi√ß√£o;
    - O controle de posi√ß√£o deve ser incrementado;
- Ao final, o vetor estar√° ordenado crescentemente

#### MERGE SORT

O Merge Sort tem bom desempenho em qualquer situa√ß√£o, seja referente ao tamanho do vetor ou √† ordena√ß√£o inicial dos dados. Baseado na t√©cnica de divis√£o para conquista, utiliza a defini√ß√£o de uma posi√ß√£o central do vetor para dividir o vetor em sub vetor da esquerda e da direita e intercala os dados. Utiliza recursividade.

DESCRI√á√ÉO:

- Pegar um vetor (Ou parte dele)
- Identificar a posi√ß√£o central do vetor e dividi-lo em 2 (posi√ß√£o inicial ‚Äì meio ; meio + 1 ‚Äì posi√ß√£o final)
- Recursivamente, ir dividindo em sub vetores de esquerda e direita at√© que se encontre um vetor de 1 posi√ß√£o, retornando o pr√≥prio vetor;
- Nesse ponto, se retorna ao vetor anterior que deve intercalar os valores a fim de orden√°-los
- A fun√ß√£o de intercalar precisa conhecer a posi√ß√£o inicial, a posi√ß√£o final e o meio do vetor (ou sub vetor)
- A fun√ß√£o de intercalar deve gerar um vetor auxiliar, com o tamanho do vetor inicial, mas com dados apenas nas posi√ß√µes do sub vetor passado como par√¢metro
- Define-se como ponteiros:
    - esquerda iniciando na posi√ß√£o inicial
    - direita, iniciando na posi√ß√£o do meio + 1
- Intercalar significa fazer os seguintes testes aninhados, percorrendo o novo vetor de posi√ß√£o inicial para a posi√ß√£o final, controlando as posi√ß√µes por um contador
- Para cada posi√ß√£o do novo vetor:
    - Se o ponteiro da esquerda √© maior que a posi√ß√£o do meio, o vetor inicial na posi√ß√£o do contador, recebe o valor do novo vetor na posi√ß√£o do ponteiro √† direita. Incrementa-se o ponteiro da direita;
    - Sen√£o, se o ponteiro da direta √© maior que a posi√ß√£o do fim, o vetor inicial na posi√ß√£o do contador, recebe o valor do novo vetor na posi√ß√£o do ponteiro √† esquerda. Incrementa-se o ponteiro da esquerda;
    - Sen√£o, se o valor do novo vetor na posi√ß√£o do ponteiro √† esquerda √© menor que o valor do novo vetor na posi√ß√£o do ponteiro √† direita, o vetor inicial na posi√ß√£o do contador, recebe o valor do novo vetor na posi√ß√£o do ponteiro √† esquerda. Incrementa-se o ponteiro da esquerda;
    - Sen√£o, o vetor inicial na posi√ß√£o do contador, recebe o valor do novo vetor na posi√ß√£o do ponteiro √† direita. Incrementa-se o ponteiro da direita;
- O comportamento recursivo vai fazer com que os sub vetores retornem ordenados e desempilhando at√© a ordena√ß√£o do vetor inicial

#### QUICK SORT
O Quick Sort √© considerado um dos algoritmos com melhor desempenho. Pode ter menor desempenho que o Bubble Sort para vetores pequenos, mas tem um √≥timo desempenho para vetores m√©dios ou grandes. √â baseado na t√©cnica de divis√£o para conquista (Dividir para conquistar), sendo que a utilizada √© denominada particionamento, utilizando um pivot, tal que, os n√∫meros √† esquerda s√£o menores ou iguais ao pivot e os n√∫meros √† direita s√£o maiores. Para melhor desenvolvimento, se usa recursividade.

DESCRI√á√ÉO:

- Pegar um vetor (Ou parte dele)
- Verifica se √© um vetor de mais de 1 posi√ß√£o
    - Caso seja de 1 posi√ß√£o, j√° est√° ordenado
- Defina, arbitrariamente, a primeira posi√ß√£o como um piv√¥, portanto, a valida√ß√£o ser√° feita da 2¬™ posi√ß√£o at√© a √∫ltima
- Marcar a segunda posi√ß√£o com um ponteiro da esquerda e a √∫ltima com um ponteiro
da direita
- Enquanto o ponteiro da esquerda se mantiver √† esquerda do ponteiro da direita, validar:
    - Enquanto o valor do ponteiro da esquerda for menor ou igual ao valor do piv√¥ e o ponteiro da esquerda continuar √† esquerda do ponteiro da direita, o ponteiro da esquerda incrementa 1. Se alguma condi√ß√£o falhar, o incremento cessa;
    - Enquanto o valor do ponteiro da direita for maior que o piv√¥ e o ponteiro da esquerda continuar √† esquerda ou igualar ao ponteiro da direita, o ponteiro da direita decrementa 1. Se alguma condi√ß√£o falhar, o decremento cessa;
    - Se incremento do ponteiro da esquerda e decremento do ponteiro da direita cessarem, mas o ponteiro da esquerda continuar √† esquerda do ponteiro da direita, os valores cujos √≠ndices forem, ponteiro da esquerda e ponteiro da direita, mudam de lugar. Incrementa-se o ponteiro da esquerda e decrementa-se o ponteiro da direita;
- Quando o ponteiro da direita, passar √† esquerda do ponteiro da esquerda, o valor do piv√¥ troca de lugar com o valor cujo √≠ndice √© o ponteiro da direita
- A partir desse momento, com o piv√¥ em algum lugar entre o in√≠cio e o fim do vetor inicial, este valor j√° est√° na sua posi√ß√£o definitiva restando um (sub)vetor √† esquerda e um (sub)vetor √† direita.
-Recursivamente, a fun√ß√£o usada com vetor inicial, deve ser chamada novamente (sem retorno), para ordenar o sub vetor da esquerda e, sequencialmente, o da direita.
- Essa recursividade deve seguir at√© que o subvetor fique com 1 √∫nica posi√ß√£o, condi√ß√£o de parada da recursividade.
-Neste ponto, o vetor estar√° ordenado

## [ExercicioPilha1](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/ExercicioPilha1)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=14DiL64nYCp3fmOKjFqlAmNO2hn2gPL0a&arquivo=ExerciciosAulaPilhasDinamicas.pdf)

### [Exerc√≠cio 1](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha1/src/view/Exercicio01.java)

Fazer um teste de mesa do algoritmo abaixo, deixando expl√≠cito os valores de sa√≠da em console e a estrutura da pilha

    Pilha p = new Pilha();
    int[] vetor = {100, 200, 1, 50, 39, 44, 25, 16, 99, 45, 33, 18, 102, 92};
    int tamanhoVetor = vetor.length;
    Para (i = 0 ; i < tamanhoVetor ; i++) {
        Se (pilhaVazia() == verdadeiro) {
            p.push(vetor[i] - 10);
        } Senao Se (vetor[i] mod 5 == 0) {
            p.push(vetor[i] / 5);
        } Senao Se (vetor[i] mod 3 == 0) {
            p.push(vetor[i] * 3);
        } Senao {
            int v1 = p.pop();
            escreva (v1 / 2);
        }
    }

### [Exerc√≠cio 3](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha1/src/view/Exercicio03.java)

Baseado na l√≥gica do Exerc√≠cio 2, criar uma aplica√ß√£o Java, baseada na biblioteca de pilha de int, que fa√ßa:
1) Criar uma classe view (Principal.java) que, na main:
    - a. Pe√ßa ao usu√°rio um valor inteiro de 0 a 10 (Caso o usu√°rio digite um valor fora desses limites, pedir novamente, at√© que o valor atenda √† solicita√ß√£o);
2) Criar uma classe controller chamada FatController, que tenha um m√©todo fatorial(int valor): int e fa√ßa:
    - a. Inicialize uma pilha
    - b. Usando a pilha como suporte, calcule o fatorial do valor de entrada 
    - c. O m√©todo deve retornar esse valor 
3) O m√©todo main da classe Principal.java deve chamar o m√©todo fatorial(int valor): long e exibir em console o valor do fatorial.

O m√©todo fatorial(int valor): long deve estar baseado nas opera√ß√µes da pilha de inteiros (push(), pop(), size(), top(), isEmpty())

## [ExercicioPilha2](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/ExercicioPilha2)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1EzVw7a07L1lyTCv0iRfoRdaH6-1aWk0P&arquivo=04-PilhasDinamicas.pdf)

### [Exerc√≠cio 1. a](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha2/src/view/Exercicio0101.java)

Simular o comportamento de pilhas din√¢micas para os algoritmos abaixo ( A simula√ß√£o deve deixar evidente a pilha que sobrou na mem√≥ria):

a)
    
    Para (i = 0 ; i < 10 ; i++) {
        Se (i % 2 == 0) {
            Push(i * i);
        } Sen√£o {
            Se (i <= 5) {
                Push(i);
            } Sen√£o {
                Pop();
            }
        }
        Top();
    }
    Size();

### [Exerc√≠cio 1. b](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha2/src/view/Exercicio0102.java)

Simular o comportamento de pilhas din√¢micas para os algoritmos abaixo ( A simula√ß√£o deve deixar evidente a pilha que sobrou na mem√≥ria):

b)

    Para (i = 100 ; i < 115 ; i++) {
        Se (isEmpty()) {
            Push(i + 100);
        } Sen√£o {
            Se (Size() <= 4) {
                Push(i + 50);
            } Sen√£o {
                Pop();
            }
        }
        Top();
    }
    Size();

### [Exerc√≠cio 3](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha2/src/view/Exercicio03.java)

Implementar um novo projeto Java com base biblioteca PilhaInt que permita a convers√£o de decimais para bin√°rios, a qual se d√° dividindo, sucessivamente, o valor de entrada por 2 e concatenando os restos da divis√£o do √∫ltimo para o primeiro.

O projeto deve ter uma classe ConverteController no package controller, que inicialize uma pilha de inteiros e com um m√©todo decToBin(int decimal): String, que, recebendo um n√∫mero decimal e realizando as opera√ß√µes, ir√° inserindo os restos das divis√µes na pilha. Ao t√©rmino do empilhamento, dever√° ser feita a opera√ß√£o de desempilhar, concatenando cada n√∫mero desempilhado (Convertendo para String) com o pr√≥ximo, at√© a pilha esvaziar.

Deve-se ter tamb√©m uma classe Principal no package view que permita ao usu√°rio inserir um n√∫mero decimal limitado a 1000.

## [ExercicioPilha3](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/ExercicioPilha3)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1FBbk5qjFDMhNx0cOkeLIcQbOBDEtOdrz&arquivo=05-ExerciciosPilhasDinamicas.pdf)

### [Exerc√≠cio 2](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha3/src/view/Exercicio02.java)

Considere o vetor a seguir:
    
    0 5 7 -4 3 5 -2 -1 10 4 3 -6 2 -9 1 -5
Fazer um algoritmo, em Java, utilizando a biblioteca PilhaInt, inicializar uma pilha de inteiros e resolva conforme as condi√ß√µes:
- O vetor deve ser percorrido do primeiro ao √∫ltimo elemento
- Caso seja um n√∫mero positivo ou 0, fazer o push do valor
- Caso seja um n√∫mero negativo, fazer o pop de 2 valores, som√°-los, fazer o push  do n√∫mero negativo e o push do resultado da soma 
- Ao t√©rmino do vetor, apresentar a quantidade de valores presentes na pilha

### [Exerc√≠cio 3](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha3/src/view/Exercicio03.java)

Considere a pilha abaixo, j√° formada. 

    J
    G
    R
    B
    H
    L
    W
Demonstrando em c√≥digo ou teste de mesa, criar uma sequ√™ncia de opera√ß√µes de pilha que d√™ a seguinte sa√≠da:

Console:
    
    R W
Pilha Final:
    
    K
    G
    M
    B
    L

### [Exerc√≠cio 4](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha3/src/view/Exercicio04.java)

Implementar um novo projeto Java com a biblioteca PilhaInt.

Esse projeto deve implementar uma solu√ß√£o para uma calculadora em Nota√ß√£o  Polonesa Reversa (NPR), tamb√©m conhecida como posfixa. Calculadoras HP, como a 48G ou a 12C utilizam esse formato de c√°lculo, em detrimento da maneira alg√©brica (infixa).

A l√≥gica da NPR se d√° como a seguir:

- Nota√ß√£o Polonesa Reversa: 
- (O v√≠deo [https://www.youtube.com/watch?v=-b-f9-9_xAI](https://www.youtube.com/watch?v=-b-f9-9_xAI) mostra a HP 50G em opera√ß√µes infixa e posfixa)
    - Enquanto for digitado n√∫mero, ele ser√° empilhado.
    - Quando for digitada uma opera√ß√£o (+,-,*,/), 2 valores devem ser desempilhados, se faz a opera√ß√£o com eles e o resultado retorna √† pilha
    - √â importante verificar que a pilha deve ter, no m√≠nimo 2 valores para fazer a opera√ß√£o

O projeto deve ter uma classe de controle (NPRController) que inicializa uma nova Pilha e deve ter duas opera√ß√µes:
- Opera√ß√£o insereValor(Pilha p, int valor):void, faz um push() na pilha
- Opera√ß√£o npr(Pilha p, String op):int. O m√©todo deve verificar se a String se trata de uma opera√ß√£o (+,-,*,/), verifica se √© poss√≠vel fazer 2 pop() e, em sendo poss√≠vel, fazer os 2 pop(), fazer a opera√ß√£o, gravar em uma vari√°vel resultado (que √© o retorno da opera√ß√£o) e fazer o push() do resultado.
    - Para opera√ß√µes de subtra√ß√£o e divis√£o (que a ordem importa), fazer o valor do 2¬∫ pop() opera√ß√£o valor do 1¬∫ pop(), ou seja o valor mais antigo √† esquerda da opera√ß√£o
    - Se n√£o houverem 2 valores, deve-se lan√ßar um Exception de pilha com valores insuficientes

A classe view Principal, deve inicializar a pilha e solicitar dados (n√∫mero ou opera√ß√£o) ao usu√°rio at√© alguma condi√ß√£o de encerramento, definido por voc√™.

### [Exerc√≠cio 5](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha3/src/view/Exercicio05.java)

Considerando a biblioteca PilhaString, j√° criada, fa√ßa:

Criar um projeto Java (Palindromos) e importe a biblioteca PilhaStrings. Esse novo projeto ir√° receber uma cadeia de Strings do usu√°rio e demonstrar para ele se essa palavra se trata ou n√£o de um Pal√≠ndromo.

Pal√≠ndromo √© uma cadeia de caracteres que se l√™ da direita para a esquerda e da esquerda para a direita e a sequ√™ncia de caracteres √© a mesma, como em arara, ovo, subinoonibus, por exemplo.

A classe PalindromoController no package controller deve ter 2 m√©todos:
- O m√©todo invertePalavra que recebe um String e retorna o String invertido. Os 
m√©todos push(), pop(), isEmpty() devem ser usados para esse fim;
- O m√©todo comparaPalavras, que recebe o String, o String j√° invertido e retorna 
um boolean (True para Pal√≠ndromo e False para N√£o Pal√≠ndromo)

A classe Principal, no package view, no seu m√©todo Main, deve inicializar uma pilha e exibir a possibilidade de o usu√°rio inserir uma cadeia de Strings e retornar a ele se √© ou n√£o um pal√≠ndromo. Todos os m√©todos devem receber a pilha criada no m√©todo Main como par√¢metro.

Dica: Para inverter, pode-se usar os m√©todos substring ou charAt

### [Exerc√≠cio 6](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha3/src/view/Exercicio06.java)

Considerando a biblioteca PilhaString, j√° criada, fa√ßa:

Criar um projeto Java (HistoricoSim) e importe a biblioteca PilhaStrings. Esse novo projeto simular√° uma fun√ß√£o presente nos navegadores Web, a fun√ß√£o de hist√≥rico.

A fun√ß√£o de hist√≥rico empilha os endere√ßos de sites acessados.

A classe Principal, no package view, deve ter na Main, a cria√ß√£o de uma Pilha denominada hist√≥rico e deve dar ao usu√°rio a possibilidade de inserir um novo endere√ßo no hist√≥rico, remover o √∫ltimo endere√ßo da pilha, saber qual foi o √∫ltimo endere√ßo visitado. Um menu deve ser criado.

A classe HistoricoController deve ter os m√©todos de valida√ß√£o das opera√ß√µes oferecidas na Main da Classe Principal. Todos os m√©todos devem receber a pilha criada no m√©todo Main como par√¢metro.
- O m√©todo de inserir um novo endere√ßo, deve-se verificar antes, se o endere√ßo √© v√°lido, um endere√ßo v√°lido come√ßa com http:// e, na sequ√™ncia, deve ter algo no formato www.endere√ßo.com (podendo ser, .com, .co.uk, .com.br, etc.). N√£o 
ser√£o aceitos sites sem www;
- O m√©todo de remover o √∫ltimo endere√ßo deve dar um erro se o hist√≥rico estiver 
vazio ou desempilhar o √∫ltimo endere√ßo;
- O m√©todo de consultar o √∫ltimo endere√ßo, deve dar um erro se o hist√≥rico estiver 
vazio ou apresentar o √∫ltimo endere√ßo, sem remov√™-lo.

## [AlgoritmosFila](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/ExercicioPilha3)

### [PDF](http://www.leandrocolevati.com.br/downloadmateriais?idFile=1FEDAE4tyO14cmilJrcTIr2IMuXl0NaDO&arquivo=06-FilasDinamicas.pdf)

### [Exerc√≠cio 2](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/ExercicioPilha3/src/view/Exercicio02.java)