# Estrutura De Dados

Conte√∫do das aulas e exerc√≠cios propostos na mat√©ria Estrutura de Dados ministrada pelo professor Leandro Colevati, cursada no 3¬∫ semestre do curso de an√°lise e desenvolvimento de sistemas na Faculdade de Tecnologia da Zona Leste (FATEC-ZL).

# Exerc√≠cios propostos

## [Aula01](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Aula01)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=12k7kal6sYeTY5oH6SeJsrnss2RDhzBFv&arquivo=ExerciciosAulaRecursividade.pdf)

Resolver, por recursividade, os problemas abaixo, fazendo o desenho do teste da solu√ß√£o, apresentando o ponto de parada e o retorno da fun√ß√£o para a pr√≥xima chamada. Fazer a implementa√ß√£o em Java na sequ√™ncia. Carregar o c√≥digo no Github.

- 1 - Criar uma fun√ß√£o recursiva que receba 2 valores A e B e, por somas, apresente o resultado da multiplica√ß√£o de A por B.

- 2 - Criar uma fun√ß√£o recursiva que receba o dividendo e o divisor de uma opera√ß√£o de divis√£o e, por subtra√ß√µes, exiba o resto da divis√£o.

- 3 - Construir uma fun√ß√£o recursiva que receba um vetor e seu tamanho e apresente a quantidade de n√∫meros pares existentes no vetor. Considere que a entrada deve ser, apenas de n√∫meros naturais diferentes de zero.

## [Recursividade01](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade01)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1EsAiBxl4nHoHmPSFZ7dj_2BiY4kkpdHa&arquivo=01-Recursividade.pdf) (pag. 17 a 20)

### [Exerc√≠cio 1](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/Recursividade01/src/controller/Exercicio01.java) 

Crie uma fun√ß√£o recursiva que exiba o resultado do fatorial de um n√∫mero (Pela limita√ß√£o da recursividade, o n√∫mero de entrada dever√°ser baixo para n√£o dar estouro(limite de entrada = 12)):

O c√≥digo deve trazer como coment√°rios:

- a) A condi√ß√£o de parada
- b) Como escrever a fun√ß√£o para o termo n em fun√ß√£o do termo anterior

### [Exerc√≠cio 2](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/Recursividade01/src/controller/Exercicio02.java) 

Crie uma fun√ß√£o recursiva que exiba o total de elementos negativos de um vetor de inteiros, de N posi√ß√µes, passado como par√¢metro:

O c√≥digo deve trazer como coment√°rios:

- a) A condi√ß√£o de parada
- b) Como escrever a fun√ß√£o para o termo n em fun√ß√£o do termo anterior

### [Exerc√≠cio 3](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/Recursividade01/src/controller/Exercicio03.java)

Crie uma fun√ß√£o recursiva que exiba a quantidade de d√≠gitos de um n√∫mero inteiro passado como par√¢metro:

O c√≥digo deve trazer como coment√°rios:

- a) A condi√ß√£o de parada
- b) Como escrever a fun√ß√£o para o termo n em fun√ß√£o do termo anterior

### [Exerc√≠cio 4](https://github.com/Maicaoxd/Estrutura-De-Dados/blob/main/Recursividade01/src/controller/Exercicio04.java)

Crie uma fun√ß√£o recursiva que exiba o resultado da invers√£o de uma cadeia de caracteres (Ex.: entrada = teste ; sa√≠da = etset):

Deve se utilizar a fun√ß√£o SUBSTRING da Java

O c√≥digo deve trazer como coment√°rios:

- a) A condi√ß√£o de parada
- b) Como escrever a fun√ß√£o para o termo n em fun√ß√£o do termo anterior

## [Recursividade02.01](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.01/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Criar uma aplica√ß√£o em Java que tenha uma fun√ß√£o recursiva que calcule o somat√≥rio do N primeiros n√∫mero NATURAIS (a fun√ß√£o deve retornar zero para n√∫meros negativos)
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
condi√ß√£o de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
rela√ß√£o de chamada dos passos;

## [Recursividade02.02](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.02/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Criar uma aplica√ß√£o em Java que tenha uma fun√ß√£o recursiva que, recebendo um n√∫mero inteiro, converta para bin√°rio. Entrada limitada a 2000.
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
condi√ß√£o de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
rela√ß√£o de chamada dos passos;

## [Recursividade02.03](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.03/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Criar uma aplica√ß√£o em Java que tenha uma fun√ß√£o recursiva que, recebendo um n√∫mero inteiro (N), apresente a sa√≠da da somat√≥ria

    ùëÜ = 1 + 1/2 + 1/3 + 1/4 + ‚Ä¶ + 1/N

- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a condi√ß√£o de
parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a rela√ß√£o de chamada dos passos;

## [Recursividade02.04](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.04/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Criar uma aplica√ß√£o em Java que tenha uma fun√ß√£o recursiva que, recebendo um numero inteiro de 10 a 999999 e recebendo um 2¬∫ n√∫mero inteiro (de 0 a 9), tenha uma fun√ß√£o recursiva que apresente quantas vezes o 2¬∫ n√∫mero aparece no primeiro.

- Exemplo 1: 1¬∫. N√∫mero = 523578; 2¬∫. N√∫mero = 5; retorno aparece 2 vezes

- Exemplo 2: 1¬∫. N√∫mero = 836363; 2¬∫. N√∫mero = 3; retorno aparece 3 vezes

- A valida√ß√£o da entrada e do d√≠gito deve ser feito na main da aplica√ß√£o e n√£o na fun√ß√£o recursiva;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a condi√ß√£o de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a rela√ß√£o de chamada dos passos;

- Dica para a resolu√ß√£o do exerc√≠cio
    
    Exemplo: N√∫mero 1234

        1234 / 10 = 123 com resto 4
        123 / 10 = 12 com resto 3
        12 / 10 = 1 com resto 2
        1 / 10 = 0 com resto 1

    Exemplo: N√∫mero 8647

        8647 / 10 = 864 com resto 7
        864 / 10 = 86 com resto 4
        86 / 10 = 8 com resto 6
        8 / 10 = 0 com resto 8

## [Recursividade02.05](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.05/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Considere a s√©rie de Fibonacci:
 - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...

- Escrever uma fun√ß√£o recursiva que, dado uma posi√ß√£o da s√©rie, a fun√ß√£o
retorne seu valor. Entrada limitada a 20.
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a condi√ß√£o
de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a rela√ß√£o de
chamada dos passos;

## [Recursividade02.06](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/Recursividade02.06/src)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F3oK4A5hZDmuT9cdDsnbioQzb9QKMnaw&arquivo=02-ExerciciosRecursividade.pdf)

Considerando exerc√≠cios realizados anteriormente, criar uma fun√ß√£o recursiva que solucione a fun√ß√£o (Entrada limitada a 10):

    ùëÜ = 1 + 1/2! + 1/3! + 1/4! + ‚Ä¶ + 1/ùëÅ!
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
condi√ß√£o de parada;
- O C√≥digo deve apresentar, em formato de coment√°rio, como foi definida a
rela√ß√£o de chamada dos passos;

## [AlgoritmosOrdenacao](https://github.com/Maicaoxd/Estrutura-De-Dados/tree/main/AlgoritmosOrdenacao/src/br/edu/fateczl/ordenacao)

### [PDF](https://leandrocolevati.com.br/downloadmateriais?idFile=1F-sHe4u0eYJK8kl7xLWQY5bprglPfYv-&arquivo=03-AlgoritmosOrdenacao.pdf)

#### BUBBLE SORT

O Bubble Sort √© baseado em um algoritmo bastante simples, mas tem como comportamento percorrer o vetor diversas vezes, o que pode ser de bom desempenho com vetores pequenos e menos desordenados, mas perde desempenho em vetores m√©dios ou grandes.

DESCRI√á√ÉO:

- Pegar um vetor
- O n√∫mero de repeti√ß√µes dever√° ser igual ao tamanho do vetor
- A din√¢mica se d√° como segue:
    - Da primeira posi√ß√£o do vetor, at√© a pen√∫ltima posi√ß√£o;
    - Verificar se a posi√ß√£o atual √© maior que a pr√≥xima;
    - Se for, elas devem trocar de posi√ß√£o;
    - O controle de posi√ß√£o deve ser incrementado;
- Ao final, o vetor estar√° ordenado crescentemente

#### MERGE SORT

O Merge Sort tem bom desempenho em qualquer situa√ß√£o, seja referente ao tamanho do vetor ou √† ordena√ß√£o inicial dos dados. Baseado na t√©cnica de divis√£o para conquista, utiliza a defini√ß√£o de uma posi√ß√£o central do vetor para dividir o vetor em sub vetor da esquerda e da direita e intercala os dados. Utiliza recursividade.

DESCRI√á√ÉO:

- Pegar um vetor (Ou parte dele)
- Identificar a posi√ß√£o central do vetor e dividi-lo em 2 (posi√ß√£o inicial ‚Äì meio ; meio + 1 ‚Äì posi√ß√£o final)
- Recursivamente, ir dividindo em sub vetores de esquerda e direita at√© que se encontre um vetor de 1 posi√ß√£o, retornando o pr√≥prio vetor;
- Nesse ponto, se retorna ao vetor anterior que deve intercalar os valores a fim de orden√°-los
- A fun√ß√£o de intercalar precisa conhecer a posi√ß√£o inicial, a posi√ß√£o final e o meio do vetor (ou sub vetor)
- A fun√ß√£o de intercalar deve gerar um vetor auxiliar, com o tamanho do vetor inicial, mas com dados apenas nas posi√ß√µes do sub vetor passado como par√¢metro
- Define-se como ponteiros:
    - esquerda iniciando na posi√ß√£o inicial
    - direita, iniciando na posi√ß√£o do meio + 1
- Intercalar significa fazer os seguintes testes aninhados, percorrendo o novo vetor de posi√ß√£o inicial para a posi√ß√£o final, controlando as posi√ß√µes por um contador
- Para cada posi√ß√£o do novo vetor:
    - Se o ponteiro da esquerda √© maior que a posi√ß√£o do meio, o vetor inicial na posi√ß√£o do contador, recebe o valor do novo vetor na posi√ß√£o do ponteiro √† direita. Incrementa-se o ponteiro da direita;
    - Sen√£o, se o ponteiro da direta √© maior que a posi√ß√£o do fim, o vetor inicial na posi√ß√£o do contador, recebe o valor do novo vetor na posi√ß√£o do ponteiro √† esquerda. Incrementa-se o ponteiro da esquerda;
    - Sen√£o, se o valor do novo vetor na posi√ß√£o do ponteiro √† esquerda √© menor que o valor do novo vetor na posi√ß√£o do ponteiro √† direita, o vetor inicial na posi√ß√£o do contador, recebe o valor do novo vetor na posi√ß√£o do ponteiro √† esquerda. Incrementa-se o ponteiro da esquerda;
    - Sen√£o, o vetor inicial na posi√ß√£o do contador, recebe o valor do novo vetor na posi√ß√£o do ponteiro √† direita. Incrementa-se o ponteiro da direita;
- O comportamento recursivo vai fazer com que os sub vetores retornem ordenados e desempilhando at√© a ordena√ß√£o do vetor inicial

#### QUICK SORT
O Quick Sort √© considerado um dos algoritmos com melhor desempenho. Pode ter menor desempenho que o Bubble Sort para vetores pequenos, mas tem um √≥timo desempenho para vetores m√©dios ou grandes. √â baseado na t√©cnica de divis√£o para conquista (Dividir para conquistar), sendo que a utilizada √© denominada particionamento, utilizando um pivot, tal que, os n√∫meros √† esquerda s√£o menores ou iguais ao pivot e os n√∫meros √† direita s√£o maiores. Para melhor desenvolvimento, se usa recursividade.

DESCRI√á√ÉO:

- Pegar um vetor (Ou parte dele)
- Verifica se √© um vetor de mais de 1 posi√ß√£o
    - Caso seja de 1 posi√ß√£o, j√° est√° ordenado
- Defina, arbitrariamente, a primeira posi√ß√£o como um piv√¥, portanto, a valida√ß√£o ser√° feita da 2¬™ posi√ß√£o at√© a √∫ltima
- Marcar a segunda posi√ß√£o com um ponteiro da esquerda e a √∫ltima com um ponteiro
da direita
- Enquanto o ponteiro da esquerda se mantiver √† esquerda do ponteiro da direita, validar:
    - Enquanto o valor do ponteiro da esquerda for menor ou igual ao valor do piv√¥ e o ponteiro da esquerda continuar √† esquerda do ponteiro da direita, o ponteiro da esquerda incrementa 1. Se alguma condi√ß√£o falhar, o incremento cessa;
    - Enquanto o valor do ponteiro da direita for maior que o piv√¥ e o ponteiro da esquerda continuar √† esquerda ou igualar ao ponteiro da direita, o ponteiro da direita decrementa 1. Se alguma condi√ß√£o falhar, o decremento cessa;
    - Se incremento do ponteiro da esquerda e decremento do ponteiro da direita cessarem, mas o ponteiro da esquerda continuar √† esquerda do ponteiro da direita, os valores cujos √≠ndices forem, ponteiro da esquerda e ponteiro da direita, mudam de lugar. Incrementa-se o ponteiro da esquerda e decrementa-se o ponteiro da direita;
- Quando o ponteiro da direita, passar √† esquerda do ponteiro da esquerda, o valor do piv√¥ troca de lugar com o valor cujo √≠ndice √© o ponteiro da direita
- A partir desse momento, com o piv√¥ em algum lugar entre o in√≠cio e o fim do vetor inicial, este valor j√° est√° na sua posi√ß√£o definitiva restando um (sub)vetor √† esquerda e um (sub)vetor √† direita.
-Recursivamente, a fun√ß√£o usada com vetor inicial, deve ser chamada novamente (sem retorno), para ordenar o sub vetor da esquerda e, sequencialmente, o da direita.
- Essa recursividade deve seguir at√© que o subvetor fique com 1 √∫nica posi√ß√£o, condi√ß√£o de parada da recursividade.
-Neste ponto, o vetor estar√° ordenado